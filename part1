#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <sstream>
#include <iomanip>
#include <locale.h>
#include <windows.h>

#define ARCH_CLIENTES "C:\\Users\\micaela\\Downloads\\clientes (3).csv"
#define ARCH_DESTINOS "C:\\Users\\micaela\\Downloads\\destinos.csv"
#define INGRESOS_ARCH "C:\\Users\\micaela\\Documents\\ingresos.txt"
#define SALTO cout<<"\n";
#define TAB cout<<"\t";

using namespace std;

bool verificar_archivo(const char*);
short test();
void imprimir_archivo(const char*);

struct clientes_struct {
    string Number;
    string Gender;
    string GivenName;
    string MiddleInitial;
    string Surname;
    string StreetAddress;
    string City;
    string State;
    string ZipCode;
    string EmailAddress;
    string TelephoneNumber;
    string Birthday;
    string Age;
    string CCType;
    string CCNumber;
    string CVV2;
    string CCExpires;
    string Codigo;
    string Plazas;
};

struct destinos_struct {
    string nombre;
    string Destino;
    int dias;
    double costo;
    string partida;
    string cod;
    int vacantes;
};

class Gestion {
private:
    vector<clientes_struct> clientes_clase;
    vector<destinos_struct> destinos_clase;
    double ingresos;

public:
    void cargarClientesDesdeCSV();
    void cargarPaquetesDesdeCSV();
    void hacerReserva(const string& numberCliente, const string& codPaquete, int vacantes);
    void eliminarReserva(const string& numberCliente, const string& codPaquete, int vacantes);
    clientes_struct& buscarCliente_por_numero(const string& numeroBuscado);
    destinos_struct& buscarPaquetePorCodigo(const string& codigoBuscado);
    void mostrarPaquetes();
    void mostrarIngresos();
    void registrarEnCSV(const string& nombreCliente, const string& destino, int plazas);
};

clientes_struct& Gestion::buscarCliente_por_numero(const string& numeroBuscado) {
    for (auto& cliente : clientes_clase) {
        if (cliente.Number == numeroBuscado) {
            return cliente;
        }
    }
    return clientes_clase[0];
}

destinos_struct& Gestion::buscarPaquetePorCodigo(const string& codigoBuscado) {
    for (auto& paquete : destinos_clase) {
        if (paquete.cod == codigoBuscado) {
            return paquete;
        }
    }
    return destinos_clase[0];
}

void Gestion::cargarClientesDesdeCSV() {
    ifstream archivo(ARCH_CLIENTES);
    string linea;
    char delimitador = ',';

    if (!archivo.is_open()) {
        cout << "Error al abrir el archivo de clientes." << endl;
        return;
    }

    getline(archivo, linea);

    while (getline(archivo, linea)) {
        stringstream stream(linea);
        clientes_struct cliente;

        getline(stream, cliente.Number, delimitador);
        getline(stream, cliente.Gender, delimitador);
        getline(stream, cliente.GivenName, delimitador);
        getline(stream, cliente.MiddleInitial, delimitador);
        getline(stream, cliente.Surname, delimitador);
        getline(stream, cliente.StreetAddress, delimitador);
        getline(stream, cliente.City, delimitador);
        getline(stream, cliente.State, delimitador);
        getline(stream, cliente.ZipCode, delimitador);
        getline(stream, cliente.EmailAddress, delimitador);
        getline(stream, cliente.TelephoneNumber, delimitador);
        getline(stream, cliente.Birthday, delimitador);
        getline(stream, cliente.Age, delimitador);
        getline(stream, cliente.CCType, delimitador);
        getline(stream, cliente.CCNumber, delimitador);
        getline(stream, cliente.CVV2, delimitador);
        getline(stream, cliente.CCExpires, delimitador);
        getline(stream, cliente.Codigo, delimitador);
        getline(stream, cliente.Plazas, delimitador);
        clientes_clase.push_back(cliente);
    }

    archivo.close();
}

void Gestion::cargarPaquetesDesdeCSV() {
    ifstream archivo(ARCH_DESTINOS);
    string linea;
    char delimitador = ',';

    if (!archivo.is_open()) {
        cout << "Error al abrir el archivo de paquetes." << endl;
        return;
    }

    getline(archivo, linea);

    while (getline(archivo, linea)) {
        stringstream stream(linea);
        destinos_struct paquete;

        getline(stream, paquete.nombre, delimitador);
        getline(stream, paquete.Destino, delimitador);
        stream >> paquete.dias;
        stream.ignore();
        stream >> paquete.costo;
        stream.ignore();
        getline(stream, paquete.partida, delimitador);
        getline(stream, paquete.cod, delimitador);
        stream >> paquete.vacantes;
        stream.ignore();

        destinos_clase.push_back(paquete);
    }

    archivo.close();
}

void Gestion::hacerReserva(const string& numberCliente, const string& codPaquete, int vacantes) {
    clientes_struct& cliente = buscarCliente_por_numero(numberCliente);
    destinos_struct& paquete = buscarPaquetePorCodigo(codPaquete);

    if (cliente.Number.empty() || paquete.cod.empty()) {
        cout << "Cliente o paquete no encontrado." << endl;
        return;
    }

    if (paquete.vacantes < vacantes) {
        cout << "No hay suficientes vacantes para el paquete seleccionado." << endl;
        return;
    }

    ofstream archivo(ARCH_CLIENTES, ios::app);
    archivo << numberCliente << "," << codPaquete << "," << vacantes << endl;
    archivo.close();

    paquete.vacantes -= vacantes;
    ingresos += vacantes * paquete.costo;

    cout << "Reserva realizada exitosamente.<< endl. Vacantes disponibles para el paquete " << codPaquete << " actualizadas a : " << vacantes << endl;

    ofstream archivo_destinos(ARCH_DESTINOS);
    if (!archivo_destinos.is_open()) {
        cout << "Error al abrir el archivo de destinos." << endl;
        return;
    }

    archivo_destinos << "nombre,Destino,dias,costo,partida,cod,vacantes" << endl;
    for (const auto& paquete : destinos_clase) {
        archivo_destinos << paquete.nombre << "," << paquete.Destino << "," << paquete.dias << ","
            << paquete.costo << "," << paquete.partida << "," << paquete.cod << ","
            << paquete.vacantes << endl;
    }
    archivo_destinos.close();

    registrarEnCSV(buscarCliente_por_numero(numberCliente).GivenName, buscarPaquetePorCodigo(codPaquete).Destino, vacantes);
}

void Gestion::eliminarReserva(const string& numberCliente, const string& codPaquete, int vacantes) {
    clientes_struct& cliente = buscarCliente_por_numero(numberCliente);
    destinos_struct& paquete = buscarPaquetePorCodigo(codPaquete);

    if (cliente.Number.empty() || paquete.cod.empty()) {
        cout << "Cliente o paquete no encontrado." << endl;
        return;
    }


    ifstream archivo(ARCH_CLIENTES);
    ofstream temp("temp.txt");

    string linea;
    while (getline(archivo, linea)) {
        stringstream stream(linea);
        string numCliente, codPaqueteReservado;
        int plazasReservadas;

        getline(stream, numCliente, ',');
        getline(stream, codPaqueteReservado, ',');
        stream >> plazasReservadas;
        stream.ignore();

        if (numCliente == numberCliente && codPaqueteReservado == codPaquete) {
            paquete.vacantes += plazasReservadas;
        }
        else {

            temp << numCliente << "," << codPaqueteReservado << "," << plazasReservadas << endl;
        }
    }

    archivo.close();
    temp.close();

    remove(ARCH_CLIENTES);
    rename("temp.txt", ARCH_CLIENTES);

    cout << "Reserva eliminada exitosamente." << endl;
}

void Gestion::mostrarPaquetes() {
    cout << "Paquetes Turísticos Disponibles:" << endl;
    SALTO;
    for (const auto& paquete : destinos_clase) {
        cout << "Nombre: " << paquete.nombre << ", "
            << "Destino: " << paquete.Destino << ", "
            << "Días: " << paquete.dias << ", "
            << "Costo: $" << fixed << setprecision(2) << paquete.costo << ", "
            << "Partida: " << paquete.partida << ", "
            << "Código: " << paquete.cod << ", "
            << "Vacantes Disponibles: " << paquete.vacantes << endl;
    }
}

void Gestion::mostrarIngresos() {
    cout << "Ingresos totales de la empresa: $" << fixed << setprecision(2) << ingresos << endl;
}

void Gestion::registrarEnCSV(const string& nombreCliente, const string& destino, int plazas) {
    ofstream archivo("Registros.csv", ios::app);

    if (!archivo.is_open()) {
        cout << "Error al abrir el archivo de registros." << endl;
        return;
    }

    archivo << nombreCliente << "," << destino << "," << plazas << endl;

    cout << "Reserva registrada exitosamente en Registros.csv" << endl;

    archivo.close();
}

int main() {
    setlocale(LC_ALL, "spanish");
    SetConsoleCP(1252);
    SetConsoleOutputCP(1252);
    system("COLOR 90");

    string nombre_cliente, destino;
    int plazas;

    Gestion empresa_turismo;
    empresa_turismo.cargarClientesDesdeCSV();
    empresa_turismo.cargarPaquetesDesdeCSV();
    //empresa_turismo.registrarEnCSV(nombre_cliente, destino, plazas);

    cout << "Bienvenido a nuestra agencia de turismo. "<< endl;
    SALTO;

    while (true) {
        cout << "Menú de Opciones:" << endl;
        cout << "1. Mostrar Paquetes Turísticos Disponibles" << endl;
        cout << "2. Realizar Reserva" << endl;
        cout << "3. Eliminar Reserva" << endl;
        cout << "4. Mostrar Ingresos Totales de la Empresa" << endl;
        cout << "5. Crear Archivo de Registros" << endl;
        cout << "6. Salir" << endl;
        cout << "Ingrese el número de la opción que desea ejecutar: ";

        int opcion;
        cin >> opcion;

        switch (opcion) {
        case 1:
            empresa_turismo.mostrarPaquetes();
            break;
        case 2: {
            string numero_cliente, codigo_destino;
            int numero_de_plazas;

            SALTO;
            cout << "Ingrese el ID del cliente: ";
            cin >> numero_cliente;

            int numero = stoi(numero_cliente);
            if (numero < 1 || numero > 100) {
                cout << "Número de cliente fuera del rango válido (1 al 100)." << endl;
                break;
            }

            cout << "Ingrese el código de destino que desea reservar: ";
            cin >> codigo_destino;

            cout << "Ingrese el número de plazas que desea reservar: ";
            cin >> numero_de_plazas;

            empresa_turismo.hacerReserva(numero_cliente, codigo_destino, numero_de_plazas);
            break;
        }
        case 3: {
            string numero_cliente, codigo_destino;
            int numero_de_plazas;

            SALTO;
            cout << "Ingrese el ID del cliente: ";
            cin >> numero_cliente;

            cout << "Ingrese el código de destino de la reserva que desea eliminar: ";
            cin >> codigo_destino;

            cout << "Ingrese el número de plazas que desea liberar: ";
            cin >> numero_de_plazas;

            empresa_turismo.eliminarReserva(numero_cliente, codigo_destino, numero_de_plazas);
            break;
        }
        case 4:
            empresa_turismo.mostrarIngresos();
            break;
        case 5:
            cout << "Ingrese el nombre del cliente: ";
            fflush(stdin);
            cin >> nombre_cliente;

            cout << "Ingrese el destino: ";
            fflush(stdin);
            cin >> destino;

            cout << "Ingrese el número de plazas: ";
            fflush(stdin);
            cin >> plazas;

    empresa_turismo.registrarEnCSV(nombre_cliente, destino, plazas);
    break;
        case 6:
            cout << "Gracias por utilizar nuestro servicio. ¡Hasta luego!" << endl;
            return 0;
        default:
            cout << "Opción no válida. Por favor, ingrese un número válido de opción." << endl;
            break;
        }
        SALTO;
    }

    return 0;
}
